#!/usr/local/bin/node
'use strict';
/*
 please keep 3th party libs away
 */
var fs = require("fs"),
    util = require("util"),
    exec = require('child_process').exec;

/**
 * w/o 3th party this is the easiest possible method to clone object
 * @param object to be deep cloned
 */
function clone(object) {
    return JSON.parse(JSON.stringify(object));
}

/**
 * read json from file
 * @param rcDefinitionFile
 */
function readJsonFile(rcDefinitionFile) {
    return JSON.parse(fs.readFileSync(rcDefinitionFile));
}

/**
 * read pv configuration from server
 * @param k8sServer server url or default
 * @returns {Promise} pv object
 */
function readK8SPV(k8sServer) {
    return new Promise((resolve, reject) => {
        var serverCommand;
        if(k8sServer === undefined) {
            serverCommand = "";
        } else {
            serverCommand = "-s " + k8sServer;
        }
        exec(util.format("kubectl %s get pv -o json", serverCommand), function (error, stdout, stderr) {
            if(error) {
                reject(error);
            } else {
                resolve(JSON.parse(stdout));
            }
        });
    });
}

/**
 * returns labels from replication controller
 * @param definition
 * @returns {*}
 */
function readDefinitionSpec(definition) {
    return  definition.metadata.labels;
}

/**
 * find volumes by labels
 * @param definitionSpec replication controller definition with labels
 * @param layout kubectl get pv -o json
 * @returns {Array.<T>|*}
 */
function findVolumes(definitionSpec, layout) {
    return layout.items.filter(item => {
        let labels = item.metadata.labels;
        return definitionSpec.app == labels.app && definitionSpec.role == labels.role;
    });
}
/**
 * wrap list of replication controllers with replication controller list
 * @param definitions
 * @returns {{kind: string, apiVersion: string, items: *}}
 */
function wrapAsReplicationControllerList(definitions) {
    return {
        kind: "ReplicationControllerList",
        apiVersion: "v1",
        items: definitions
    };
}

/**
 * generate layout out from definition and pv layout
 * @param definition rc definition
 * @param layout pv layout
 * @returns {{kind, apiVersion, items}|{kind: string, apiVersion: string, items: *}}
 */
function createLayout(definition, layout) {
    let definitionSpec = readDefinitionSpec(definition);
    let volumes = findVolumes(definitionSpec, layout);
    let newDefinitions = volumes.map(item => {
        let itemZone = item.metadata.labels.zone;
        let result = clone(definition);
        // set metadata name
        result.metadata.name += util.format("-%s", itemZone);
        // add new label with zone
        result.spec.selector.zone = itemZone;
        result.metadata.labels.zone = itemZone;
        result.spec.template.metadata.labels.zone = itemZone;
        // define node selector
        result.spec.template.spec.nodeSelector = {
            zone: itemZone
        };
        // replace volume
        result.spec.template.spec.volumes[0] = {
            name: result.spec.template.spec.volumes[0].name,
            awsElasticBlockStore: item.spec.awsElasticBlockStore

        };
        return result;
    });
    return wrapAsReplicationControllerList(newDefinitions);
}

// dummy argument validation
// expected structure:
// node k8as example.json or node k8as example.json k8s:port
if(process.argv.length < 3) {
    console.error("invalid usage. example: node k8as.js rcFile.json");
    console.error("or with custom k8s      node k8as.js rcFile.json 172.21.0.48:8080");
    process.exit();
}

// expect destination as 3 argument
var definitionFile = process.argv[2];
// expect k8sServer [optional] as 4 argument
var k8sServer = process.argv[3];

// read pv definitions from k8s
readK8SPV(k8sServer).then((pvDefinition) => {
    // create layout
    var definition = createLayout(readJsonFile(definitionFile), pvDefinition);
    // print and exit
    console.log(JSON.stringify(definition, null, 4));
    process.exit(0);
}, (err) => {
    // without k8s it is not possible to generate definition properly so complain and exit
    console.error('unable to read PV definitions from k8s', err);
    process.exit(1);
});
